// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: inventory.sql

package dbmodels

import (
	"context"
	"database/sql"
)

const addItemToInventory = `-- name: AddItemToInventory :one
INSERT INTO inventory (
    player_id,
    item_type_id,
    quantity
) VALUES (
    ?,
    ?,
    ?
)
RETURNING item_id, player_id, item_type_id, quantity
`

type AddItemToInventoryParams struct {
	PlayerID   int64
	ItemTypeID int64
	Quantity   sql.NullInt64
}

func (q *Queries) AddItemToInventory(ctx context.Context, arg AddItemToInventoryParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, addItemToInventory, arg.PlayerID, arg.ItemTypeID, arg.Quantity)
	var i Inventory
	err := row.Scan(
		&i.ItemID,
		&i.PlayerID,
		&i.ItemTypeID,
		&i.Quantity,
	)
	return i, err
}

const getItem = `-- name: GetItem :one
SELECT item_id, player_id, item_type_id, quantity FROM inventory WHERE player_id = ? AND item_id = ?
`

type GetItemParams struct {
	PlayerID int64
	ItemID   int64
}

func (q *Queries) GetItem(ctx context.Context, arg GetItemParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, getItem, arg.PlayerID, arg.ItemID)
	var i Inventory
	err := row.Scan(
		&i.ItemID,
		&i.PlayerID,
		&i.ItemTypeID,
		&i.Quantity,
	)
	return i, err
}

const getItemsByTypeID = `-- name: GetItemsByTypeID :many
SELECT item_id, player_id, item_type_id, quantity FROM inventory WHERE player_id = ? AND item_type_id = ?
`

type GetItemsByTypeIDParams struct {
	PlayerID   int64
	ItemTypeID int64
}

func (q *Queries) GetItemsByTypeID(ctx context.Context, arg GetItemsByTypeIDParams) ([]Inventory, error) {
	rows, err := q.db.QueryContext(ctx, getItemsByTypeID, arg.PlayerID, arg.ItemTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Inventory
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ItemID,
			&i.PlayerID,
			&i.ItemTypeID,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerInventory = `-- name: GetPlayerInventory :many
SELECT item_id, player_id, item_type_id, quantity FROM inventory WHERE player_id = ?
`

func (q *Queries) GetPlayerInventory(ctx context.Context, playerID int64) ([]Inventory, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerInventory, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Inventory
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ItemID,
			&i.PlayerID,
			&i.ItemTypeID,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeItemFromInventory = `-- name: RemoveItemFromInventory :exec
DELETE FROM inventory WHERE player_id = ? AND item_id = ?
`

type RemoveItemFromInventoryParams struct {
	PlayerID int64
	ItemID   int64
}

func (q *Queries) RemoveItemFromInventory(ctx context.Context, arg RemoveItemFromInventoryParams) error {
	_, err := q.db.ExecContext(ctx, removeItemFromInventory, arg.PlayerID, arg.ItemID)
	return err
}

const setItemQuantity = `-- name: SetItemQuantity :one
UPDATE inventory SET quantity = ? WHERE player_id = ? AND item_id = ? RETURNING item_id, player_id, item_type_id, quantity
`

type SetItemQuantityParams struct {
	Quantity sql.NullInt64
	PlayerID int64
	ItemID   int64
}

func (q *Queries) SetItemQuantity(ctx context.Context, arg SetItemQuantityParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, setItemQuantity, arg.Quantity, arg.PlayerID, arg.ItemID)
	var i Inventory
	err := row.Scan(
		&i.ItemID,
		&i.PlayerID,
		&i.ItemTypeID,
		&i.Quantity,
	)
	return i, err
}
